"""
Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать на
вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.

Первый — с помощью алгоритма «Решето Эратосфена».

Второй — без использования «Решета Эратосфена».
"""

import timeit
import cProfile

"""
Думаю, тут будет к месту небольшое пояснение. Я долго пытался придумать собственный способ нахождения размеров решета.
Я честно пытался читать о простых числах и их распределении в вики, но, черт подери, там же просто таблица, где все
написано, и вы эту таблицу уже использовали в своем решении ааа)) кроме того, придумать свою реализацию пи-функции в 
коде у меня не хватило мозгов - увы и ах, я всего-лишь тупой гуманитарий. когда ребята в чате пишут "пфф, эта легкотня 
была у нас на первом курсе матанализа!", я могу лишь подумать о том, что у нас на "переводе и переводоведении" не было 
ни одного курса матанализа, да что уж там - меня и логарифмы-то пугают) так что, в задачках с математикой я, как 
говорится, always at a disadvantage. В общем и целом, я всего-лишь хочу сказать, что да, ваше решение на занятии 
натолкнуло меня на мысль об использовании словаря со значениями пи-функции с википедии, а тот факт, что мой ноутбук
наглухо повис, пытаясь сгенерировать массив из миллиарда чисел (моя изначальная идея была, так сказать, "разрубить 
гордиев узел" - жестко задать довольно большой размер решета, а не мучиться с определением его размера), лишь укрепил 
мою уверенность в использовании такого подхода. Тем не менее, раз вы использовали его в решении, которое 
продемонстрировали на занятии, и я делаю это задание уже после занятия, и я осведомлен о таком решении именно после
просмотра вебинара, получается, что я так и так списал код у вас. Так что если это незачет, то что ж поделать...
"""


def sieve(n):
    primes_dict = {4: 10, 25: 10 ** 2, 168: 10 ** 3, 1229: 10 ** 4, 9592: 10 ** 5, 78498: 10 ** 6, 664579: 10 ** 7,
                   5761455: 10 ** 8}
    size = 0
    if n > 5761455:
        return f'Привет, я тупая функция, больше 5761455 простых чисел я не знаю ыы.'
    else:
        for key in primes_dict:
            if n <= key:
                size = primes_dict[key]
                break
    array = [i for i in range(size)]
    array[1] = 0
    for i in range(2, size):
        if array[i] != 0:
            """
            "На практике, алгоритм можно улучшить следующим образом. На шаге № 3 числа можно зачеркивать начиная сразу с 
            числа p2, потому что все составные числа меньше него уже будут зачеркнуты к этому времени. И, 
            соответственно, останавливать алгоритм можно, когда p2 станет больше, чем n."
            да ведь если просто читать эту статью на вики, то получается ваш код)) эх, доберись я до этого до 
            занятия, был бы молодцом)
            """
            j = i ** 2
            while j < size:
                array[j] = 0
                j += i
    primes_array = [_ for _ in array if _ != 0]
    return primes_array[n - 1]


# ну что ж, проверим эту функцию
print(timeit.timeit('sieve(1)', number=1000, globals=globals()))  # 0.00700347700058046
print(timeit.timeit('sieve(10)', number=1000, globals=globals()))  # 0.03862268600005336
print(timeit.timeit('sieve(100)', number=1000, globals=globals()))  # 0.28713364099985483
print(timeit.timeit('sieve(1000)', number=1000, globals=globals()))  # 2.78327449399967
print(timeit.timeit('sieve(10000)', number=1000, globals=globals()))  # 389.1328042969999
print(timeit.timeit('sieve(100000)', number=1000, globals=globals()))  # 4154.073400252

cProfile.run('sieve(1)')
#         1    0.000    0.000    0.000    0.000 <string>:1(<module>)
#         1    0.000    0.000    0.000    0.000 task_2.py:32(sieve)
#         1    0.000    0.000    0.000    0.000 task_2.py:43(<listcomp>)
#         1    0.000    0.000    0.000    0.000 task_2.py:58(<listcomp>)
#         1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}
#         1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
cProfile.run('sieve(10)')
#         1    0.000    0.000    0.000    0.000 <string>:1(<module>)
#         1    0.000    0.000    0.000    0.000 task_2.py:32(sieve)
#         1    0.000    0.000    0.000    0.000 task_2.py:43(<listcomp>)
#         1    0.000    0.000    0.000    0.000 task_2.py:58(<listcomp>)
#         1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}
#         1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
cProfile.run('sieve(100)')
#         1    0.000    0.000    0.000    0.000 <string>:1(<module>)
#         1    0.000    0.000    0.000    0.000 task_2.py:32(sieve)
#         1    0.000    0.000    0.000    0.000 task_2.py:43(<listcomp>)
#         1    0.000    0.000    0.000    0.000 task_2.py:58(<listcomp>)
#         1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}
#         1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
cProfile.run('sieve(1000)')
#         1    0.000    0.000    0.004    0.004 <string>:1(<module>)
#         1    0.003    0.003    0.004    0.004 task_2.py:32(sieve)
#         1    0.001    0.001    0.001    0.001 task_2.py:43(<listcomp>)
#         1    0.000    0.000    0.000    0.000 task_2.py:58(<listcomp>)
#         1    0.000    0.000    0.004    0.004 {built-in method builtins.exec}
#         1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
cProfile.run('sieve(10000)')
#         1    0.007    0.007    0.390    0.390 <string>:1(<module>)
#         1    0.321    0.321    0.383    0.383 task_2.py:32(sieve)
#         1    0.036    0.036    0.036    0.036 task_2.py:43(<listcomp>)
#         1    0.027    0.027    0.027    0.027 task_2.py:58(<listcomp>)
#         1    0.000    0.000    0.390    0.390 {built-in method builtins.exec}
#         1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
cProfile.run('sieve(100000)')
#         1    0.066    0.066    4.036    4.036 <string>:1(<module>)
#         1    3.319    3.319    3.970    3.970 task_2.py:32(sieve)
#         1    0.386    0.386    0.386    0.386 task_2.py:43(<listcomp>)
#         1    0.266    0.266    0.266    0.266 task_2.py:58(<listcomp>)
#         1    0.000    0.000    4.036    4.036 {built-in method builtins.exec}
#         1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
